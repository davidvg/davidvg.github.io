<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Muerte por Checklist (Publicaciones sobre robotica)</title><link>https://davidvg.github.io/</link><description></description><atom:link href="https://davidvg.github.io/categories/robotica.xml" rel="self" type="application/rss+xml"></atom:link><language>es</language><lastBuildDate>Tue, 11 Jun 2019 11:04:08 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Simulación de circuito de lectura de tensión</title><link>https://davidvg.github.io/posts/simulacion-circuito-lectura-tension/</link><dc:creator>David Vázquez</dc:creator><description>&lt;div&gt;&lt;p&gt;Para un proyecto de robótica que estoy comenzando, basado en versiones de los rover marcianos de NASA, necesitaba diseñar un circuito para hacer la lectura de la corriente que circula por un motor controlado mediante un driver &lt;a href="https://www.allegromicro.com/~/media/Files/Datasheets/A4952-3-Datasheet.pdf"&gt;Allegro A4953&lt;/a&gt;. Este driver tiene un pin LSS en el que se puede conectar una resistencia $R_S$ para medir la corriente del motor, que se obtiene simplemente dividiendo la tensión (V_S) en la resistencia por el valor de la misma:&lt;/p&gt;
&lt;p&gt;$$
I_{motor} = \frac{V_S}{R_S}
$$&lt;/p&gt;
&lt;p&gt;Para diseñar el circuito decidí dibujar el esquema en &lt;a href="http://www.kicad-pcb.org/"&gt;KiCad&lt;/a&gt; y simularlo con &lt;a href="http://ngspice.sourceforge.net/"&gt;ngspice&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Esquema" src="https://davidvg.github.io/images/a4953_current_sensing.png" width="80%"&gt;&lt;/p&gt;
&lt;p&gt;La simulación muestra la gráfica siguiente para los parámetros $V_S$, $V_M$ y $V_{OUT}$ cuando $V_S$ se hace variar entre $-0.44V$ y $+0.44V$.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Plot" src="https://davidvg.github.io/images/output.jpg" width="50%"&gt;&lt;/p&gt;
&lt;p&gt;La simulación devuelve los siguientes valores de tensión para los principales puntos de funcionamiento:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="right"&gt;$V_S$&lt;/th&gt;
&lt;th&gt;$V_M$&lt;/th&gt;
&lt;th&gt;$V_{OUT}$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="right"&gt;$-0.44$&lt;/td&gt;
&lt;td&gt;$0.23$&lt;/td&gt;
&lt;td&gt;$0.90$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;$0.00$&lt;/td&gt;
&lt;td&gt;$0.66$&lt;/td&gt;
&lt;td&gt;$2.63$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;$+0.44$&lt;/td&gt;
&lt;td&gt;$1.09$&lt;/td&gt;
&lt;td&gt;$4.35$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;Procedimiento del cálculo&lt;/h4&gt;
&lt;p&gt;La hoja de datos da una expresión para calcular $R_S$:&lt;/p&gt;
&lt;p&gt;$$
I_{max} = \frac{V_{ref}}{A_v R_S}
$$&lt;/p&gt;
&lt;p&gt;siendo $I_{max}$ la corriente máxima del motor, $V_{ref}$ la tensión aplicada en el pin VREF (se usarán 5V) y $A_v$ una ganancia que en la hoja de datos se define con valor 10. Con esto, se puede calcular el valor de $R_S$ adecuado para este caso:&lt;/p&gt;
&lt;p&gt;$$
R_S = \frac{V_{ref}}{A_v  I_{max}} = \frac{5V}{10 \times 1.1A} = 0.45 \Omega
$$&lt;/p&gt;
&lt;p&gt;Según las especificaciones del driver, el valor máximo admisible en LSS, en valor absoluto, es de $0.5 V$. Eligiendo $R_S= 0.4 \Omega$, la tensión máxima que se tendrá en LSS es, en valor absoluto:&lt;/p&gt;
&lt;p&gt;$$
V_S = 0.4 \Omega \times 1.1A = 0.44V &amp;lt; 0.5V
$$&lt;/p&gt;
&lt;p&gt;Como resultado, en LSS se tendrán tensiones en el rango $(-0.44V, +0.44V)$ (línea azul en la gráfica) en función de la corriente que circula por el motor.&lt;/p&gt;
&lt;p&gt;Este rango de tensiones será leído mediante el &lt;a href="https://es.wikipedia.org/wiki/Conversor_de_se%C3%B1al_anal%C3%B3gica_a_digital"&gt;conversor analógico/digital (ADC)&lt;/a&gt; de un &lt;a href="https://store.arduino.cc/arduino-nano"&gt;Arduino Nano&lt;/a&gt;, que registra tensiones entre $0$ y $5V$ con una resolución de 10 bit (1024 cuentas), por lo que es necesario adaptar estas tensiones a valores adecuados para tener una resolución decente en la lectura. Idealmente, se intentaría usar todo el rango $(0V, 5V)$ del ADC, pero conviene dejar márgenes de seguridad para asegurar que no se alcanzan los máximos y para evitar que el amplificador operacional que hará la adaptación trabaje en los extremos ($0V$ y $VCC$), lo que puede producir valores erróneos.&lt;/p&gt;
&lt;p&gt;La adaptación de tensiones se realiza usando un &lt;a href="http://www.ti.com/lit/ds/symlink/lm358.pdf"&gt;amplificador operacional LM358&lt;/a&gt; configurado como &lt;a href="https://es.wikipedia.org/wiki/Amplificador_operacional#Amplificador_no_inversor"&gt;amplificador no inversor&lt;/a&gt;. En esta configuración, la ganancia es positiva, por lo que el primer obstáculo está en transformar el rango de tensiones en LSS para que todas sean positivas. Para ello se coloca en serie con la tensión $V_S$ un diodo alimentado desde el pin de $3.3V$ del Arduino que sumará su tensión de codo, unos $0.66V$ de promedio, al valor de $V_S$, por lo que se pasa a tener un rango de tensiones $(Vd-Vs, Vd+Vs) = (0.23V, 1.09V)$, todas positivas. Estas tensiones, $V_M$ en el esquema y en la gráfica, se pasan como entrada a la etapa amplificadora para adaptarlas al rango $(0V, 5V)$ del ADC.&lt;/p&gt;
&lt;p&gt;La ganancia del amplificador no inversor viene dada por&lt;/p&gt;
&lt;p&gt;$$
A_v = 1 + \frac{R_4}{R_2+R_3}
$$&lt;/p&gt;
&lt;p&gt;y la tensión en la salida será&lt;/p&gt;
&lt;p&gt;$$
V_{OUT} = A_v   V_M
$$&lt;/p&gt;
&lt;p&gt;Según las especificaciones del LM358, en la salida de este operacional se pueden obtener tensiones entre $0V$ y $VCC-1.5V$, por lo que si fijamos un valor máximo aproximado de tensión en el ADC de 4.5V se tiene que VCC debe ser igual a 6V, que es una de las tensiones que se va a usar en la placa definitiva. Ese valor máximo también da un margen de seguridad en la tensión medida en el ADC.&lt;/p&gt;
&lt;p&gt;Para obtener 4.5V en la salida necesitamos una ganancia de tensión igual a&lt;/p&gt;
&lt;p&gt;$$\frac{4.5V}{1.09V} = 4.13 = 1 + \frac{R_4}{R_2+R_3}$$&lt;/p&gt;
&lt;p&gt;por lo que la relación $\frac{R_4}{R_2+R_3}$ tiene que ser menor o igual a $3.13$ para no sobrepasar los $4.5V$.  Seleccionando $R_2+R_3 = 110 \: k \Omega$ y $R_4 = 330 \:k \Omega$ se obtiene una relación de $3$ y una ganancia $A_v = 4$.&lt;/p&gt;
&lt;p&gt;Con esta ganancia el rango de tensiones en la salida del amplificador será&lt;/p&gt;
&lt;p&gt;$$
V_{OUT} = (A_v \times 0.23, \: Av \times 1.09) = (0.90V, \: 4.35V)
$$&lt;/p&gt;
&lt;p&gt;que se corresponden con valores del ADC de $(184, 890)$, utilizando un $69 \%$ del rango del ADC.&lt;/p&gt;
&lt;h4&gt;Resolución en corriente del ADC&lt;/h4&gt;
&lt;p&gt;Se puede calcular la resolución de la medida de corriente por el motor, es decir cuánto cambia la corriente por cada cuenta del ADC.&lt;/p&gt;
&lt;p&gt;La tensión de salida del amplificador es:&lt;/p&gt;
&lt;p&gt;$$
V_{OUT} = A_v(R_S i_S + V_d)
$$&lt;/p&gt;
&lt;p&gt;siendo $i_S$ la corriente que circula por $R_S$ (se desprecia la corrientes que circula por el diodo, del orden de $1 mA$) y $V_d$ la tensión de codo en el diodo.&lt;/p&gt;
&lt;p&gt;Expresado como cuentas del ADC:&lt;/p&gt;
&lt;p&gt;$$
N = \frac{1024}{5}  V_{OUT}
$$&lt;/p&gt;
&lt;p&gt;Si tomamos dos medidas consecutivas del ADC, $N1$ y $N2 = N1 + 1$:&lt;/p&gt;
&lt;p&gt;$$
N2 - N1 = \frac{1024}{5} Av (R_S i_2 + V_d) - \frac{1024}{5} Av (R_S * i_1 + V_d)
$$&lt;/p&gt;
&lt;p&gt;Operando:&lt;/p&gt;
&lt;p&gt;$$
1 = \frac{1024}{5} Av R_S (i_2 - i_1)&lt;/p&gt;
&lt;p&gt;$$&lt;/p&gt;
&lt;p&gt;Y se tiene:&lt;/p&gt;
&lt;p&gt;$$
(i2 - i1) = \Delta i = \frac{5}{1024 \: A_v R_S} = 3.05 \dfrac{mA}{cuenta}
$$&lt;/p&gt;
&lt;p&gt;Es decir, se tiene una resolución en la medida de corriente que circula por el motor de unos $3 \: mA$.&lt;/p&gt;&lt;/div&gt;</description><category>driver</category><category>electronica</category><category>kicad</category><category>mathjax</category><category>robotica</category><category>spice</category><guid>https://davidvg.github.io/posts/simulacion-circuito-lectura-tension/</guid><pubDate>Mon, 10 Jun 2019 17:30:00 GMT</pubDate></item><item><title>Turtlebot3</title><link>https://davidvg.github.io/posts/turtlebot3/</link><dc:creator>David Vázquez</dc:creator><description>&lt;div&gt;&lt;p&gt;Este año los Reyes Magos se han puesto espléndidos y me han traído un &lt;a href="http://www.robotis.us/turtlebot-3/"&gt;Turtlebot3&lt;/a&gt;, el modelo Burger para ser más exactos. Bueno, en realidad no han sido los Reyes, sino que me lo he auto-regalado.&lt;/p&gt;
&lt;!-- &lt;img style="float: center;" src="/home/david/git/blog/output/images/turtlebot3.jpg" width=480 &gt; --&gt;

&lt;p&gt;&lt;img alt="turtlebot3" src="https://davidvg.github.io/images/turtlebot3.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Aunque también sirve para pasar un buen rato jugando con él, en realidad es una plataforma de desarrollo de robótica, ya que es un robot modular y totalmente personalizable. Es un robot de dos ruedas y una bola que actúa como rueda castor o giratoria. Se organiza en 4 niveles mediante plataformas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nivel 1: aloja los motores y la batería.&lt;/li&gt;
&lt;li&gt;Nivel 2: en él se encuentra la placa &lt;a href="http://wiki.ros.org/opencr"&gt;OpenCR&lt;/a&gt;, basada en &lt;a href="https://www.arduino.cc/"&gt;Arduino&lt;/a&gt;, y que incluye el hardware necesario para implementar el Turtlebot3: sensores, drivers para motores, interfaces de comunicaciones, etc.&lt;/li&gt;
&lt;li&gt;Nivel 3: en él se coloca la &lt;a href="https://www.raspberrypi.org/products/raspberry-pi-3-model-b/"&gt;Raspberry Pi 3&lt;/a&gt; en la que se ejecuta &lt;a href="http://www.ros.org/"&gt;ROS&lt;/a&gt;, el sistema operativo del robot. También tiene espacio suficiente para añadir más sensores o componentes.&lt;/li&gt;
&lt;li&gt;Nivel 4: es el nivel superior y sobre el que se coloca el &lt;a href="https://en.wikipedia.org/wiki/Lidar"&gt;LIDAR&lt;/a&gt;, que se emplea para medir distancias y que a grandes rasgos es similar al &lt;a href="https://es.wikipedia.org/wiki/Radar"&gt;RADAR&lt;/a&gt; pero usando la luz de un láser.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Como cada nivel es idéntico a los demás, se pueden añadir más niveles si se necesitan.&lt;/p&gt;
&lt;p&gt;El proyecto es &lt;a href="https://es.wikipedia.org/wiki/C%C3%B3digo_abierto"&gt;código&lt;/a&gt; abierto, u open source, tanto el &lt;a href="https://es.wikipedia.org/wiki/Hardware_libre"&gt;hardware&lt;/a&gt; como el &lt;a href="https://es.wikipedia.org/wiki/Software_libre"&gt;software&lt;/a&gt;, por lo que es posible modificarlo, adaptarlo y configurarlo a medida. Todas las partes que forman los niveles, los mecanismos de sujeción, etc. se pueden imprimir en una impresora 3D usando los diseños que están disponibles en la web.&lt;/p&gt;
&lt;p&gt;De momento estoy haciendo pruebas, ya que el Turtlebot3 se desarrolló para la versión de ROS Kinetic Kame, que a su vez es compatible con &lt;a href="https://www.ubuntu.com/"&gt;Ubuntu&lt;/a&gt; 16.04, mientras que yo tengo instalado Ubuntu 18.04, para la que Kinetic no es compatible; sí lo es la última versión disponible de ROS, Melodic Morenia, a la que se está portando el código de Turtlebot3.&lt;/p&gt;
&lt;p&gt;Hasta ahora he conseguido que funcionen sin demasiados problemas los modos básicos de teleoperación del robot, mediante teclado y joystick, y las funciones básicas de &lt;a href="https://es.wikipedia.org/wiki/Localizaci%C3%B3n_y_modelado_simult%C3%A1neos"&gt;SLAM&lt;/a&gt; y cartografiado, así como la navegación autónoma básica usando el mapa creado.&lt;/p&gt;&lt;/div&gt;</description><category>robotica</category><category>slam</category><category>turtlebot</category><category>turtlebot3</category><guid>https://davidvg.github.io/posts/turtlebot3/</guid><pubDate>Thu, 24 Jan 2019 16:00:00 GMT</pubDate></item></channel></rss>